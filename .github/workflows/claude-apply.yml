name: Claude Auto-Apply (Stage 2)

on:
  workflow_dispatch:
    inputs:
      analysis_run_id:
        description: 'Run ID of the analysis workflow'
        required: true
        type: string
      trigger_run_id:
        description: 'Original failing run ID'
        required: true
        type: string
      target_branch:
        description: 'Branch that had the failure'
        required: true
        type: string
      target_sha:
        description: 'SHA of the failing commit'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  apply-fix:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ secrets.PAT_TOKEN }}
      MAX_ATTEMPTS: "5"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git identity
        shell: bash
        run: |
          set -euo pipefail
          git config --global user.email "claude-auto-fix@anthropic.com"
          git config --global user.name "Claude Auto-Fix Bot"

      - name: Download analysis results
        uses: actions/download-artifact@v4
        with:
          name: claude-analysis-${{ inputs.trigger_run_id }}
          path: analysis-results/
          run-id: ${{ inputs.analysis_run_id }}
          github-token: ${{ secrets.PAT_TOKEN }}

      - name: Verify analysis results
        id: verify
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "analysis-results/fix.patch" ]; then
            echo "No fix patch found in analysis results"
            exit 1
          fi
          if [ ! -f "analysis-results/metadata.json" ]; then
            echo "No metadata found in analysis results"
            exit 1
          fi

          echo "=== Analysis Metadata ==="
          cat analysis-results/metadata.json || true
          echo "=== Fix Patch Preview ==="
          head -n 20 analysis-results/fix.patch || true

          TARGET_WORKFLOW=$(jq -r '.target_workflow' analysis-results/metadata.json)
          if [ -z "$TARGET_WORKFLOW" ] || [ "$TARGET_WORKFLOW" = "null" ]; then
            TARGET_WORKFLOW=".github/workflows/provision-from-prompt.yml"
          fi
          echo "TARGET_WORKFLOW=$TARGET_WORKFLOW" >> "$GITHUB_OUTPUT"

      - name: Create fix branch and apply patch
        id: patch
        shell: bash
        run: |
          set -euo pipefail
          BASE_BRANCH="${{ inputs.target_branch }}"
          BRANCH="ai-fix/${BASE_BRANCH}"
          TARGET_WORKFLOW="${{ steps.verify.outputs.TARGET_WORKFLOW }}"

          git fetch --no-tags origin "${{ inputs.target_sha }}"
          git checkout -B "$BRANCH" "${{ inputs.target_sha }}"

          echo "Attempting to apply Claude's fix..."

          if git apply --index analysis-results/fix.patch 2>/dev/null; then
            echo "Patch applied successfully with direct method"
          elif git apply --3way --index analysis-results/fix.patch 2>/dev/null; then
            echo "Patch applied successfully with 3-way merge"
          elif patch -p1 --dry-run < analysis-results/fix.patch >/dev/null 2>&1 && patch -p1 < analysis-results/fix.patch; then
            echo "Patch applied successfully with patch command"
            git add -A
          else
            echo "Standard patch application failed, attempting manual fixes..."
            if [ -f "$TARGET_WORKFLOW" ]; then
              cp "$TARGET_WORKFLOW" "${TARGET_WORKFLOW}.bak"

              # Remove stderr redirections that can break YAML or commands inside Actions
              sed -i 's/ 2>\/dev\/null//g' "$TARGET_WORKFLOW"

              # Build Python fixer script with echo lines
              rm -f fix_workflow.py
              echo "import os" >> fix_workflow.py
              echo "target_file = os.environ.get('TARGET_WORKFLOW', '.github/workflows/provision-from-prompt.yml')" >> fix_workflow.py
              echo "with open(target_file, 'r', encoding='utf-8') as f:" >> fix_workflow.py
              echo "    content = f.read()" >> fix_workflow.py
              echo "content = content.replace(' 2>/dev/null', '')" >> fix_workflow.py
              echo "lines = content.split('\\n')" >> fix_workflow.py
              echo "fixed_lines = []" >> fix_workflow.py
              echo "in_heredoc = False" >> fix_workflow.py
              echo "heredoc_delimiter = None" >> fix_workflow.py
              echo "for line in lines:" >> fix_workflow.py
              echo "    if '<<' in line and ('FALLBACK_JSON' in line or 'EOF' in line):" >> fix_workflow.py
              echo "        heredoc_delimiter = 'FALLBACK_JSON' if 'FALLBACK_JSON' in line else 'EOF'" >> fix_workflow.py
              echo "        in_heredoc = True" >> fix_workflow.py
              echo "        fixed_lines.append(line)" >> fix_workflow.py
              echo "    elif in_heredoc and line.strip() == heredoc_delimiter:" >> fix_workflow.py
              echo "        fixed_lines.append(line)" >> fix_workflow.py
              echo "        if heredoc_delimiter == 'FALLBACK_JSON':" >> fix_workflow.py
              echo "            fixed_lines.append('EOF')" >> fix_workflow.py
              echo "        in_heredoc = False" >> fix_workflow.py
              echo "        heredoc_delimiter = None" >> fix_workflow.py
              echo "    else:" >> fix_workflow.py
              echo "        fixed_lines.append(line)" >> fix_workflow.py
              echo "content = '\\n'.join(fixed_lines)" >> fix_workflow.py
              echo "with open(target_file, 'w', encoding='utf-8') as f:" >> fix_workflow.py
              echo "    f.write(content)" >> fix_workflow.py

              TARGET_WORKFLOW="$TARGET_WORKFLOW" python3 fix_workflow.py
              rm -f fix_workflow.py

              if git diff --quiet "${TARGET_WORKFLOW}.bak" "$TARGET_WORKFLOW"; then
                echo "No changes applied, restoring original"
                mv "${TARGET_WORKFLOW}.bak" "$TARGET_WORKFLOW"
                echo "Unable to apply any fixes"
                exit 1
              else
                echo "Manual fixes applied successfully"
                git add "$TARGET_WORKFLOW"
                rm -f "${TARGET_WORKFLOW}.bak"
              fi
            else
              echo "Target workflow file not found: $TARGET_WORKFLOW"
              exit 1
            fi
          fi

          # Show staged changes
          CHANGED_FILES=$(git diff --cached --name-only)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Safelist to guard what can be changed by this job
          SAFE_GLOBS="
          .github/workflows/provision-from-prompt.yml
          website*.json
          image-prompts.json
          child-themes/**/templates/*.html
          "
          BAD=0
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            ok=0
            while IFS= read -r g; do
              [ -z "$g" ] && continue
              if python3 -c "import fnmatch, sys; print('OK' if fnmatch.fnmatch(sys.argv[1], sys.argv[2]) else '')" "$f" "$g" | grep -q OK; then
                ok=1
                break
              fi
            done <<< "$SAFE_GLOBS"
            if [ "$ok" -ne 1 ]; then
              echo "File outside safelist: $f"
              BAD=1
            fi
          done <<< "$CHANGED_FILES"
          if [ "$BAD" -eq 1 ]; then
            echo "Changes violated safelist. Aborting."
            exit 1
          fi

          # Attempts counter stored on the branch
          ATTEMPTS_FILE=".ai-fix-attempts"
          if git show HEAD:"$ATTEMPTS_FILE" >/dev/null 2>&1; then
            OLD=$(git show HEAD:"$ATTEMPTS_FILE" | tr -d '\n' || echo 0)
          else
            OLD=0
          fi
          NEW=$((OLD+1))
          echo "$NEW" > "$ATTEMPTS_FILE"
          git add "$ATTEMPTS_FILE"

          if [ "$NEW" -gt "$MAX_ATTEMPTS" ]; then
            echo "Max attempts ($MAX_ATTEMPTS) reached on this branch. Exiting."
            exit 1
          fi

          # Commit
          git commit -m "AI auto-fix attempt $NEW by Claude" \
            -m "Applied fix from analysis run ${{ inputs.analysis_run_id }}" \
            -m "Original failure: ${{ inputs.trigger_run_id }}" \
            -m "Target: $TARGET_WORKFLOW"

          # Push using PAT-authenticated remote so workflow edits are allowed
          git remote set-url origin "https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ github.repository }}.git"
          git push -u origin "$BRANCH"

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "attempts=$NEW"  >> "$GITHUB_OUTPUT"

      - name: Create or update pull request
        id: pr
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${{ steps.patch.outputs.branch }}"
          BASE_BRANCH="${{ inputs.target_branch }}"
          TITLE="AI auto-fix for workflow failure"

          if [ -f "analysis-results/summary.md" ]; then
            PR_BODY="$(cat analysis-results/summary.md)"
          else
            PR_BODY="Automated fix generated by Claude AI. Original failure: ${{ inputs.trigger_run_id }}, Analysis run: ${{ inputs.analysis_run_id }}."
          fi

          PR=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number' || true)
          if [ -z "$PR" ]; then
            gh pr create --title "$TITLE" --body "$PR_BODY" --head "$BRANCH" --base "$BASE_BRANCH"
            PR=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number')
          else
            gh pr edit "$PR" --body "$PR_BODY"
          fi

          echo "number=$PR" >> "$GITHUB_OUTPUT"
          echo "Created or updated PR #$PR"

      - name: Enable auto-merge
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          PR="${{ steps.pr.outputs.number }}"
          gh pr merge "$PR" --auto --squash

      # Re-run the target workflow on the fix branch so Stage 1 can analyse again if it still fails
      - name: Re-run target workflow on fix branch
        if: ${{ fromJSON(steps.patch.outputs.attempts) < fromJSON(env.MAX_ATTEMPTS) }}
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${{ steps.patch.outputs.branch }}"
          echo "[rerun] triggering target workflow on ref $BRANCH"

          # If you want to reuse real inputs, fetch them from the failed run API.
          # For now, provide safe defaults that satisfy required inputs.
          gh workflow run ".github/workflows/provision-from-prompt.yml" \
            --ref "$BRANCH" \
            -f prompt="Automated re-run after AI fix" \
            -f industry="auto-detect" \
            -f generate_images=true

          echo "Dispatched target workflow on $BRANCH. If it fails again, Stage 1 will fire, then Stage 2, up to ${MAX_ATTEMPTS} attempts."
