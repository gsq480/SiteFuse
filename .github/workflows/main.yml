name: Claude Auto-Fix

on:
  workflow_run:
    workflows: ["Enhanced Child Theme from Prompt"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  propose-fix:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest

    env:
      CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TARGET_WORKFLOW: .github/workflows/provision-from-prompt.yml
      # files Claude is allowed to change
      SAFE_GLOBS: |
        .github/workflows/provision-from-prompt.yml
        website*.json
        image-prompts.json
        child-themes/**/templates/*.html
      MAX_ATTEMPTS: "5"  # safety cap per branch

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install gh CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Fetch failing run logs
        run: |
          set -euo pipefail
          RUN_ID="${{ github.event.workflow_run.id }}"
          mkdir -p .ai-fix logs
          curl -sSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/logs" \
            -o logs/failure.zip
          unzip -q logs/failure.zip -d logs || true
      
      - name: Collect context
        id: ctx
        run: |
          set -euo pipefail
          SHA="${{ github.event.workflow_run.head_sha }}"
          echo "SHA=$SHA" >> $GITHUB_OUTPUT
          echo "=== Changed files at failing SHA ==="
          git fetch --no-tags origin "$SHA"
          git checkout -q "$SHA"
          # Gather key files
          mkdir -p .ai-fix
          cp -f "$TARGET_WORKFLOW" .ai-fix/ 2>/dev/null || true
          # Tail the last 300 lines of all step logs
          find logs -type f -name '*.txt' -exec tail -n 300 {} + > .ai-fix/errors.txt || true
          # Summarise safe globs for the prompt
          printf "%s\n" "$SAFE_GLOBS" > .ai-fix/safelist.txt

      - name: Ask Claude for unified diff
        id: ai
        run: |
          set -euo pipefail
          WORKFLOW_JSON=$(jq -Rs . < .ai-fix/$(basename "$TARGET_WORKFLOW"))
          ERRORS_JSON=$(jq -Rs . < .ai-fix/errors.txt)
          SAFE_JSON=$(jq -Rs . < .ai-fix/safelist.txt)
          
          # Debug: Check if we have the required data
          echo "=== Debug Info ==="
          echo "CLAUDE_API_KEY present: $([ -n "$CLAUDE_API_KEY" ] && echo "yes" || echo "no")"
          echo "Workflow JSON length: $(echo "$WORKFLOW_JSON" | wc -c)"
          echo "Errors JSON length: $(echo "$ERRORS_JSON" | wc -c)"
          
          # Create the user content by concatenating the parts
          USER_CONTENT="Repository: ${{ github.repository }}\nCommit: ${{ github.event.workflow_run.head_sha }}\nSafelist globs:\n"
          USER_CONTENT="${USER_CONTENT}$(echo "$SAFE_JSON" | jq -r .)"
          USER_CONTENT="${USER_CONTENT}\n\nFailing workflow file content:\n"
          USER_CONTENT="${USER_CONTENT}$(echo "$WORKFLOW_JSON" | jq -r .)"
          USER_CONTENT="${USER_CONTENT}\n\nTail of error logs:\n"
          USER_CONTENT="${USER_CONTENT}$(echo "$ERRORS_JSON" | jq -r .)"
          USER_CONTENT="${USER_CONTENT}\n\nReturn ONLY a valid unified diff (git patch) that fixes the failure with minimal changes."
          
          # Use jq to properly construct the JSON payload
          jq -n \
            --arg model "claude-sonnet-4-20250514" \
            --argjson max_tokens 4000 \
            --arg system "You are an expert CI engineer. You will output ONLY a unified diff patch bounded to a safelist of files. Keep changes minimal and syntactically correct. If logs show JSON being written as strings, decode them. Ensure curl blocks are correct. Ensure jq filters are type-safe. Do not touch files outside the safelist." \
            --arg user_content "$USER_CONTENT" \
            '{
              model: $model,
              max_tokens: $max_tokens,
              system: $system,
              messages: [
                {
                  role: "user", 
                  content: $user_content
                }
              ]
            }' > payload.json
          
          # Debug: Show payload size
          echo "Payload size: $(wc -c < payload.json) bytes"
          
          # Make API call with better error handling
          HTTP_CODE=$(curl -w "%{http_code}" -sS https://api.anthropic.com/v1/messages \
            -H "x-api-key: $CLAUDE_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "Content-Type: application/json" \
            -d @payload.json \
            -o response.json)
          
          echo "API HTTP Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "=== API Error Response ==="
            cat response.json || echo "No response body"
            exit 1
          fi
          
          # Extract the response with better error handling
          if ! jq -e '.content[0].text' response.json > /dev/null; then
            echo "=== Unexpected API Response Structure ==="
            cat response.json
            exit 1
          fi
          
          jq -r '.content[0].text' response.json > ai.diff.raw
          
          # Debug: Show what Claude returned
          echo "=== Claude Response Preview ==="
          head -n 20 ai.diff.raw
          
          # Strip markdown code fences if present and extract the actual diff
          if grep -q '^```diff' ai.diff.raw; then
            echo "Stripping markdown code fences..."
            sed -n '/^```diff$/,/^```$/p' ai.diff.raw | sed '1d;$d' > ai.diff
          elif grep -q '^diff --git ' ai.diff.raw; then
            echo "Raw diff format detected, using as-is..."
            cp ai.diff.raw ai.diff
          else
            echo "Attempting to extract diff from response..."
            # Try to find diff content even if not perfectly formatted
            grep -A 1000 '^diff --git ' ai.diff.raw > ai.diff || cp ai.diff.raw ai.diff
          fi
          
          # Debug: Show processed diff
          echo "=== Processed Diff Preview ==="
          head -n 10 ai.diff
          
          # basic validation - accept both git diff format and standard unified diff format
          if grep -q '^diff --git ' ai.diff || grep -q '^--- ' ai.diff; then
            echo "✅ Valid unified diff detected"
          else
            echo "Claude did not return a valid unified diff. Full response:"
            cat ai.diff.raw || echo "ai.diff.raw is empty"
            echo "=== Processed diff was ==="
            cat ai.diff || echo "ai.diff is empty"
            exit 1
          fi
          
          # sanity guard: limit size to ~50KB
          if [ "$(wc -c < ai.diff)" -gt 51200 ]; then
            echo "Proposed diff too large, aborting."
            exit 1
          fi

      - name: Create branch and apply patch
        id: patch
        run: |
          set -euo pipefail
          BASE_BRANCH="${{ github.event.workflow_run.head_branch }}"
          BRANCH="ai-fix/${BASE_BRANCH}"
          git checkout -B "$BRANCH" "${{ github.event.workflow_run.head_sha }}"
          
          # Try to apply patch with different strategies
          echo "Attempting to apply patch..."
          
          # Strategy 1: Direct application
          if git apply --index ai.diff 2>/dev/null; then
            echo "✅ Patch applied successfully with direct method"
          # Strategy 2: Apply with 3-way merge
          elif git apply --3way --index ai.diff 2>/dev/null; then
            echo "✅ Patch applied successfully with 3-way merge"
          # Strategy 3: Try with fuzz factor (allows some context mismatch)
          elif patch -p1 --dry-run < ai.diff >/dev/null 2>&1 && patch -p1 < ai.diff; then
            echo "✅ Patch applied successfully with patch command"
            git add .
          # Strategy 4: Manual application (extract and apply changes more intelligently)
          else
            echo "Standard patch failed, attempting manual application..."
            
            # Check if this is a simple content fix we can apply manually
            if grep -q "FALLBACK_JSON" ai.diff && [ -f "$TARGET_WORKFLOW" ]; then
              echo "Detected FALLBACK_JSON fix, applying manually..."
              
              # Create a backup
              cp "$TARGET_WORKFLOW" "${TARGET_WORKFLOW}.bak"
              
              # Apply some common fixes that Claude typically suggests
              # Fix 1: Remove problematic 2>/dev/null redirections
              sed -i 's/ 2>\/dev\/null//g' "$TARGET_WORKFLOW"
              
              # Fix 2: Ensure heredoc blocks have proper EOF markers
              # This is more complex, so let's just ensure basic structure is correct
              python3 -c """
import re
import sys

with open('$TARGET_WORKFLOW', 'r') as f:
    content = f.read()

# Fix common heredoc issues
# Look for FALLBACK_JSON without proper EOF
content = re.sub(
    r'(cat > [^\n]*<<[\'\"]*FALLBACK_JSON[\'\"]*\n)(.*?)(\n\s*FALLBACK_JSON)',
    r'\1\2\3\nEOF',
    content,
    flags=re.DOTALL
)

with open('$TARGET_WORKFLOW', 'w') as f:
    f.write(content)
"""
              
              if git diff --quiet "${TARGET_WORKFLOW}.bak" "$TARGET_WORKFLOW"; then
                echo "No changes applied, patch may not be relevant"
                git checkout "${TARGET_WORKFLOW}.bak"
                rm "${TARGET_WORKFLOW}.bak"
                exit 1
              else
                echo "✅ Manual fixes applied"
                git add "$TARGET_WORKFLOW"
                rm "${TARGET_WORKFLOW}.bak"
              fi
            else
              echo "❌ Unable to apply patch - incompatible changes"
              echo "Diff content:"
              head -n 50 ai.diff
              exit 1
            fi
          fi
          
          # enforce safelist: abort if staged files outside globs
          echo "Checking staged files are within safelist"
          SAFE=$(printf "%s\n" "$SAFE_GLOBS")
          BAD=0
          while IFS= read -r f; do
            ok=0
            while IFS= read -r g; do
              if python3 -c "
          import fnmatch, sys
          f = sys.argv[1]
          g = sys.argv[2]
          print('OK' if fnmatch.fnmatch(f, g) else '')
          " "$f" "$g" | grep -q OK; then 
                ok=1
                break
              fi
            done <<< "$SAFE"
            if [ "$ok" -ne 1 ]; then echo "File outside safelist: $f"; BAD=1; fi
          done < <(git diff --cached --name-only)
          if [ "$BAD" -eq 1 ]; then echo "Patch violated safelist. Aborting."; exit 1; fi

          # attempts counter on branch via a file
          ATTEMPTS_FILE=".ai-fix-attempts"
          if git show HEAD:"$ATTEMPTS_FILE" >/dev/null 2>&1; then
            OLD=$(git show HEAD:"$ATTEMPTS_FILE" | tr -d '\n' || echo 0)
          else
            OLD=0
          fi
          NEW=$((OLD+1))
          echo "$NEW" > "$ATTEMPTS_FILE"
          git add "$ATTEMPTS_FILE"

          if [ "$NEW" -gt "$MAX_ATTEMPTS" ]; then
            echo "Max attempts ($MAX_ATTEMPTS) reached on this branch. Exiting."
            exit 1
          fi

          git commit -m "AI auto-fix attempt $NEW by Claude"
          git push -u origin "$BRANCH"

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Open or update PR
        id: pr
        run: |
          set -euo pipefail
          BRANCH="${{ steps.patch.outputs.branch }}"
          TITLE="AI auto-fix for ${GITHUB_REF_NAME:-main}"
          BODY="Proposed by Claude from failing run ${{ github.event.workflow_run.id }}. Attempt recorded in .ai-fix-attempts."
          # find existing PR
          PR=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number' || true)
          if [ -z "$PR" ]; then
            gh pr create --title "$TITLE" --body "$BODY" --head "$BRANCH" --base "${{ github.event.workflow_run.head_branch }}" >/tmp/pr.txt
            PR=$(sed -n 's/.*pull\/\([0-9]\+\).*/\1/p' /tmp/pr.txt)
          else
            gh pr edit "$PR" --body "$BODY"
          fi
          echo "number=$PR" >> $GITHUB_OUTPUT

      - name: Enable auto-merge on green
        run: |
          set -euo pipefail
          PR="${{ steps.pr.outputs.number }}"
          # require checks to pass, then auto-merge with squash
          gh pr merge "$PR" --auto --squash
